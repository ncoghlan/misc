PEP: 426
Title: Metadata for Python Software Packages 2.0
Version: $Revision$
Last-Modified: $Date$
Author: Nick Coghlan <ncoghlan@gmail.com>,
        Daniel Holth <dholth@gmail.com>,
        Donald Stufft <donald@stufft.io>
BDFL-Delegate: Nick Coghlan <ncoghlan@gmail.com>
Discussions-To: Distutils SIG <distutils-sig@python.org>
Status: Draft
Type: Standards Track
Content-Type: text/x-rst
Requires: 440
Created: 30 Aug 2012
Post-History: 14 Nov 2012, 5 Feb 2013, 7 Feb 2013, 9 Feb 2013
Replaces: 345


Abstract
========

This PEP describes a mechanism for publishing and exchanging metadata
related to Python distributions. It includes specifics of the field names,
and their semantics and
usage.

This document specifies version 2.0 of the metadata format.
Version 1.0 is specified in PEP 241.
Version 1.1 is specified in PEP 314.
Version 1.2 is specified in PEP 345.

Version 2.0 of the metadata format migrates from a custom key-value format
to a JSON-compatible in-memory representation.

This version also adds fields designed to make third-party packaging of
Python software easier, defines a formal extension mechanism, and adds
support for optional dependencies. Finally, this version addresses
several issues with the previous iteration of the standard version
identification scheme.

.. note::

   "I" in this doc refers to Nick Coghlan. Daniel and Donald either wrote or
   contributed to earlier versions, and have been providing feedback as this
   initial draft of the JSON-based rewrite has taken shape.

   Metadata 2.0 represents a major upgrade to the Python packaging ecosystem,
   and attempts to incorporate experience gained over the 15 years(!) since
   distutils was first added to the standard library. Some of that is just
   incorporating existing practices from setuptools/pip/etc, some of it is
   copying from other distribution systems (like Linux distros or other
   development language communities) and some of it is attempting to solve
   problems which haven't yet been well solved by anyone (like supporting
   clean conversion of Python source packages to distro policy compliant
   source packages for at least Debian and Fedora, and perhaps other
   platform specific distribution systems).

   The current draft of the PEP very much represents a "wish list" for where
   I would like us to go. My current expectation is that we will have to
   either defer or reject entirely various aspects in order to get something
   we can support in the existing tools in a reasonable amount of time. By
   asking for the full set of features in this draft, I hope for the current
   tool developers to shoot down the aspects which aren't practical in the
   near term, while endorsing and supporting those aspects which can be
   adopted relatively easily in the Python 3.4 time frame.

   The switch to JSON also opens up some possible opportunities for
   consolidation of some fields, and raises a variety of options where I
   haven't yet made up my mind on a suitable representation. These are
   noted as open questions under the affected field definitions.
   
   There will eventually be a suite of PEPs covering various aspects of
   the metadata 2.0 format and related systems:

   * this PEP, covering the core metadata format
   * PEP 440, covering the versioning identification and selection scheme
   * a new PEP to define v2.0 of the sdist format
   * an updated wheel PEP (v1.1) to add pymeta.json
   * an updated installation database PEP both for pymeta.json and to add
     a linking scheme to better support runtime selection of dependencies,
     as well as recording which extras are currently available
   * a new static config PEP to standardise metadata generation and
     creation of sdists
   * PEP 439, covering a bootstrapping mechanism for ``pip``
   * a distutils upgrade PEP, adding metadata v2.0 and wheel support.

   It's going to take a while to work through all of these and make them
   a reality. The main change from our last attempt at this is that we're
   trying to design the different pieces so we can implement them
   independently of each other, without requiring users to switch to
   a whole new tool chain (although they may have to upgrade their existing
   ones to start enjoying the benefits in their own work).
   
   Many of the inline notes in this version of the PEP are there to aid
   reviewers that are familiar with the old metadata standards. Before this
   version is finalised, most of that content will be moved down to the
   "rationale" section at the end of the document, as it would otherwise be
   an irrelevant distraction for future readers.

.. note::

   Miscellaneous TODO items

   * Reconsider top level "test_requires" and "test_may_require"
   * Reconsider top level "docs_build_requires" and "docs_build_may_require"
   * If the docs_build requirements are separated out as their own thing,
     then build_extras can probably be killed off...
   * Or else docs_build_requires could just go into dev_requires, along with
     all the other develpoment related dependencies that aren't needed to
     create a wheel from an sdist...
   * The whole extras architecture still needs a bit of work. Is it just a
     tool for optional dependencies? Or do we want to support fully optional
     components (like C accelerator modules)?
   

Definitions
===========

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
"SHOULD", "SHOULD NOT", "RECOMMENDED",  "MAY", and "OPTIONAL" in this
document are to be interpreted as described in RFC 2119.

"Distributions" are deployable software components published through an index
server or otherwise made available for installation.

"Versions" are uniquely identified snapshots of a distribution.

"Distribution archives" are the packaged files which are used to publish
and distribute the software. "Source archives" require a build system to
be available on the target system, while "binary archives" only require that
prebuilt files be moved to the correct location on the target system. As
Python is a dynamically bound cross-platform language, many "binary"
archives will contain only pure Python source code.

"Build tools" are automated tools intended to run on development systems,
producing source and binary distribution archives. Build tools may also be
invoked by installation tools in order to install software distributed as
source archives rather than prebuilt binary archives.

"Index servers" are active distribution registries which publish version and
dependency metadata and place constraints on the permitted metadata.

"Publication tools" are automated tools intended to run on development
systems and upload source and binary distribution archives to index servers.

"Installation tools" are automated tools intended to run on production
systems, consuming source and binary distribution archives from an index
server or other designated location and deploying them to the target system.

"Automated tools" is a collective term covering build tools, index servers,
publication tools, installation tools and any other software that produces
or consumes distribution version and dependency metadata.

"Projects" refers to the developers that manage the creation of a particular
distribution.

"Legacy metadata" refers to earlier versions of this metadata specification,
along with the supporting metadata file formats defined by the
 ``setuptools`` project.


Development and distribution activities
=======================================

Making effective use of a common metadata format requires a common
understanding of the most complex development and distribution model
the format is intended to support. The metadata format described in this
PEP is based on the following activities:

* Development: during development, a user is operating from a
  source checkout (or equivalent) for the current project. Dependencies must
  be available in order to build, test and create a source archive of the
  distribution.
  
  .. note::
     As a generated file, the full distribution metadata often won't be
     available in a raw source checkout or tarball. In such cases, the
     relevant distribution metadata is generally obtained from another
     location, such as the last published release, or by generating it
     based on a command given in a standard input file
 
* Build: the build step is the process of turning a source archive into a
  binary archive. Dependencies must be available in order to build and
  create a binary archive of the distribution (including any documentation
  that is installed on target systems).

* Deployment: the deployment phase consists of two subphases:
    
  * Installation: the installation phase involves getting the distribution
    and all of its runtime dependencies onto the target system. In this
    phase, the distribution may already be on the system (when upgrading or 
    reinstalling) or else it may be a completely new installation.

  * Usage: the usage phase, also referred to as "runtime", is normal usage
    of the distribution after it has been installed on the target system.

The metadata format described in this PEP is designed to enable the
following:

* It should be practical to have separate development systems, build systems
  and deployment systems.
* It should be practical to install dependencies needed specifically to
  build source archives only on development systems.
* It should be practical to install dependencies needed specifically to
  build the software only on development and build systems, as well as
  optionally on deployment systems if installation from source archives
  is needed.
* It should be practical to install dependencies needed to run the
  distribution only on development and deployment systems.
* It should be practical to install the dependencies needed to run a
  distribution's test suite only on development systems, as well as
  optionally on deployment systems.
* It should be practical for repackagers to separate out the build
  dependencies needed to build the application itself from those required
  to build its documentation (as the documentation often doesn't need to
  be rebuilt when porting an application to a different platform).

.. note::
    
    This "most complex supported scenario" is almost *exactly* what has to
    happen to get an upstream Python package into a Linux distribution, and
    is why the current crop of automatic Python metadata -> Linux distro
    metadata converters have some serious issues, at least from the point of
    view of complying with distro packaging policies: the information
    they need to comply with those policies isn't available from the
    upstream projects, and all current formats for publishing it are
    distro specific. This means repackagers currently have to do a lot
    of work manually in order to separate out these dependencies in a
    way that complies with those policies.
    
    One thing this PEP aims to be is define a metadata format that at least
    has the *potential* to provide the info repackagers need, thus allowing
    upstream Python projects and Linux distro repackagers to collaborate more
    effectively (and, ideally, make it possible to reliably automate
    the process of converting upstream Python distributions into policy
    compliant distro packages).

    Some items in this section (and the contents of this note) will likely
    end up moving down to the "Rationale for changes from PEP 345" section.


Metadata format
===============

The format defined in this PEP is an in-memory representation of Python
distribution metadata as a string-keyed dictionary. Permitted values for
individual entries are strings, lists of strings, booleans and additional
nested string-keyed dictionaries.

Except where otherwise noted, dictionary keys in distribution metadata MUST
be valid Python identifiers in order to support attribute based metadata
access APIs.

The individual field descriptions show examples of the key name and value
as they would be serialised as part of a JSON mapping.


Metadata files
--------------

The information defined in this PEP is serialised to ``pymeta.json``
files for some use cases. As indicated by the extension, these
are JSON-encoded files. Each file consists of a single serialised mapping,
with fields as described in this PEP.

There are three standard locations for these metadata files:

* as a ``{distribution}-{version}.dist-info/pymeta.json`` file in an
  ``sdist`` source distribution archive
* as a ``{distribution}-{version}.dist-info/pymeta.json`` file in a ``wheel``
  binary distribution archive
* as a ``{distribution}-{version}.dist-info/pymeta.json`` file in a local
  Python installation database

.. note::
    
   These locations are to be confirmed, since they depend on the definition
   of sdist 2.0 and the revised installation database standard. There will
   also be a wheel 1.1 format update after this PEP is approved that
   mandates 2.0+ metadata.

Other tools involved in Python distribution may also use this format.

It is expected that these metadata files will be generated by build tools
based on other input formats (such as ``setup.py``) rather than being
edited by hand.

.. note::
    
    It may be appropriate to add a "./setup.py dist_info" command to
    setuptools to allow just the sdist metadata files to be generated
    without having to build the full sdist archive.

For backwards compatibility with older installation tools, metadata 2.0
files MAY be distributed alongside legacy metadata.

Index servers MAY allow distributions to be uploaded and installation tools
MAY allow distributions to be installed with only legacy metadata.


Core metadata
=============

This section specifies the core metadata fields that are required for every
Python distribution.

Publication tools MUST ensure at least these fields are present when
publishing a distribution.

Index servers MUST ensure at least these fields are present in the metadata
when distributions are uploaded.

Installation tools MAY refuse to accept distributions with one or more
of these fields missing.


Metadata version
----------------

Version of the file format; ``"2.0"`` is the only legal value.

Automated tools consuming metadata SHOULD warn if ``metadata_version`` is
greater than the highest version they support, and MUST fail if
``metadata_version`` has a greater major version than the highest
version they support (as described in PEP 440, the major version is the
value before the first dot).

For broader compatibility, build tools MAY choose to produce
distribution metadata using the lowest metadata version that includes
all of the needed fields.

Example::

    "metadata_version": "2.0"


Name
----

The name of the distribution.

As distribution names form the basis for URLs, filenames, command line
parameters and interoperability with other packaging systems, the permitted
characters are constrained to:

* ASCII letters (``[a-zA-Z]``)
* ASCII digits (``[0-9]``)
* underscores (``_``)
* hyphens (``-``)
* periods (``.``)

Name MUST start with an ASCII letter or digit.

All comparisons of distribution names MUST be case insensitive, and MUST
consider hyphens and underscores to be equivalent.

When converting legacy metadata, all spaces MUST be converted to hyphens,
while all other disallowed characters MUST be converted to underscores.

.. note::

    Debian doesn't actually permit underscores in names, but that seems
    unduly restrictive to me given the common practice of using
    valid Python identifiers as Python distribution names. A Debian side
    policy of converting underscores to hyphens seems easy enough to
    implement.

    We're deliberately *not* following Python 3 down the path of arbitrary
    unicode identifiers at this time. The security implications of doing so
    are substantially worse in the software distribution use case (it opens
    up far more interesting attack vectors than mere code obfuscation), the
    existing tooling really only works properly if you abide by the stated
    restrictions and changing it would require a *lot* of work for all
    the automated tools in the chain.


Example::

    "name": "ComfyChair"


Version
-------

The distribution's public version identifier, as defined in PEP 440. Public
versions are designed for consumption by automated tools and support a
variety of flexible version specification mechanisms (see PEP 440 for
details).

Example::

    "version": "1.0a2"


Additional identifying metadata
===============================

This section specifies fields that provide identifying details regarding the
distribution.

All of these fields are optional. Automated tools MUST operate correctly if
a distribution does not provide them, except for those operations which
specifically require this fields.


Build label
-----------

A relatively arbitrary build label, as defined in PEP 440. Build labels
cannot be used in ordered version comparisons, but may be used to select
an exact version (see PEP 440 for details).

Examples::

    "build_label": "1.0.0-alpha.1"

    "build_label": "1.3.7+build.11.e0f985a"

    "build_label": "v1.8.1.301.ga0df26f"

    "build_label": "2013.02.17.dev123"


Version URL
-----------

A string containing the full URL from which this specific version of the
distribution can be downloaded.  (This means that the URL can't be
something like ``"https://github.com/pypa/pip/archive/master.zip"``, but
instead must be ``"https://github.com/pypa/pip/archive/1.3.1.zip"``.)

Some appropriate targets for a version URL are a source tarball, an sdist
archive or a direct reference to a tag or specific commit in an online
version control system.

Example::
    
    "version_url": "https://github.com/pypa/pip/archive/1.3.1.zip"

.. note::
    
    This was called "Download-URL" in previous versions of the metadata. It
    has been renamed, since there are plenty of other download locations and
    this URL is meant to be a way to get the original source for development
    purposes.

    For extra fun and games, it appears that unlike "svn+ssh://",
    neither "git+ssh://" nor "hg+ssh://" natively support direct linking to a
    particular tag (hg does support direct links to bookmarks through the URL
    fragment, but that doesn't help for git and doesn't appear to be what I
    want anyway).

    However pip does have a `defined convention
    <http://www.pip-installer.org/en/latest/logic.html#vcs-support>`__ for
    this kind of link, which effectively splits a "URL" into "<repo>@<tag>".

    Alternatively, we could use a hash map to handle URL-hostile version
    control systems::

        {
            "repo_url": "git+https://github.com/pypa/pip.git",
            "tag": "1.3.1"
        }

    Either the "<repo>@<tag>" notation or the nested hash map sounds
    reasonable to me, so I'm interested in arguments one way or the other
    (in particular, if existing tools would need to convert the hash map
    form to the "<repo>@<tag>" form anyway, we may as well use the more
    concise notation in the metadata standard).


Additional descriptive metadata
===============================

This section specifies fields that provide additional information regarding
the distribution and its contents.

All of these fields are optional. Automated tools MUST operate correctly if
a distribution does not provide them.

Summary
-------

A one-line summary of what the distribution does.

Publication tools SHOULD emit a warning if this field is not provided. Index
servers MAY require that this field be present before allowing a
distribution to be uploaded.

Example::

    "summary": "A module that is more fiendish than soft cushions."

.. note::

   This used to be mandatory, and it's still highly recommended, but really,
   nothing should break even when it's missing.

   

Description
-----------

The distribution metadata should include a longer description of the
distribution that may run to several paragraphs. Software that deals
with metadata should not assume any maximum size for the description.

The distribution description can be written using reStructuredText
markup [1]_.  For programs that work with the metadata, supporting
markup is optional; programs may also display the contents of the
field as plain text without any special formatting.  This means that
authors should be conservative in the markup they use.

Example::

    "description": "The ComfyChair module replaces SoftCushions.\\n\\nUse until lunchtime, but pause for a cup of coffee at eleven."

Note that the difficulty of editing this field in a raw JSON file is one of
the main reasons this metadata interchange format is NOT recommended for use
as an input format for build tools.

.. note::
    
   Including this field directly has the potential to make metadata files
   much larger than they would otherwise be. Perhaps this should instead
   be a relative file path, specifying a flat text file containing the
   long description? (For example, ``"./README"`` or "``./README.rst``"
   for a colocated file)
   
   Another option would be to define aditional standard locations and formats
   for the "big" metadata that we don't really want in the JSON summary. In
   that case, README (with an optional extension indicating the markup
   format) would become an official part of the metadata standard.

   A third alternative would be to explicitly define an abbreviated subset
   of the metadata which *just* contained the fields potentially needed for
   dependency resolution, and left out *all* of the metadata not
   specifically related to that task. Index servers would then be expected
   to publish both the abbreviated and the full metadata for each project
   in a convenient to consume form.

   If the markup format stays embedded, it may still be beneficial to
   support other markup formats beyond ReST (notably Markdown, Asciidoc and
   raw HTML).


Keywords
--------

A list of additional keywords to be used to assist searching for the
distribution in a larger catalog.

Example::

    "keywords": ["comfy", "chair", "cushions", "too silly", "monty python"]


License
-------

A string indicating the license covering the distribution where the license
is not a simple selection from the "License" Trove classifiers. See
Classifiers" below.  This field may also be used to specify a
particular version of a license which is named via the ``Classifier``
field, or to indicate a variation or exception to such a license.

Examples::

    "license": "GPL version 3, excluding DRM provisions"

The full text of the license would normally be included in a separate
file.

.. note::
   Open question: Should we allow the metadata to specifically identify the
   license file, relative to the root of the sdist?
   
   Alternatively, we could make LICENSE a defined part of the metadata
   standard (see notes above regarding the long description field)


Classifiers
-----------

A list of strings, with each giving a single classification value
for the distribution.  Classifiers are described in PEP 301 [2].

Example::

    "classifiers": [
        "Development Status :: 4 - Beta",
        "Environment :: Console (Text Based)"
    ]


Modules
-------

A list of strings, with each giving the fully qualified name of a public
package or module provided by the distribution.

A flat list is used in order to correctly accommodate namespace packages
(where a distribution may provide subpackages or submodules without
explicitly providing the parent namespace package).

Example::

    "modules": [
        "comfy.chair"
    ]

.. note::

    Explicitly providing a list of public module names will likely help
    with enabling features in RPM like "Requires: python(requests)", as well
    as providing richer static metadata for analysis from PyPI.

    So, I'd like to keep this idea in some form, but I'm open to tinkering
    with the specifics of the syntax, including potentially moving it
    out to another file, as with the other potentially large fields
    (RPM keeps the file lists separate from the main metadata)

    On the other hand, this may be a good candidate for postponing to
    metadata 2.1.


Contact metadata
================

Contact metadata for a distribution is provided to allow users to get
access to more information about the distribution and its maintainers.

These details are recorded as mappings with the following subfields:
    
* ``name``: the name of an individual or group
* ``email``: an email address (this may be a mailing list)
* ``url``: a URL (such as a profile page on a source code hosting service)
* ``type``: one of ``"author"``, ``"maintainer"``, ``"organization"``
  or ``"individual"``

The ``name`` subfield is required, the other subfields are optional.

The different contact types are as follows:
    
* ``author``: the original creator of a distribution
* ``maintainer``: the current lead contributor for a distribution, when
  they are not the original creator
* ``individual``: any other individuals involved in the creation of the
  distribution
* ``organization``: indicates that these contact details are for an
  organization (formal or informal) rather than for a specific individual

If no specific contact type is stated, the default is ``individual``.

.. note::

   This is admittedly a little complicated, but it's designed to replace the
   Author, Author-Email, Maintainer, Maintainer-Email fields from metadata
   1.2 in a way that allows those distinctions to be fully represented for
   lossless translation, while allowing future distributions to pretty
   much ignore everything other than the contact/contributor distinction
   if they so choose.
    

Contacts
--------

A list of contact entries giving the recommended contact points for getting
more information about the project.

The example below would be suitable for a project that was in the process
of handing over from the original author to a new lead maintainer, while
operating as part of a larger development group.

Example::

    "contacts": [
      {
        "name": "Python Packaging Authority/Distutils-SIG",
        "type": "organization",
        "email": "distutils-sig@python.org",
        "url": "https://bitbucket.org/pypa/"
      },
      {   
        "name": "Samantha C.",
        "type": "maintainer",
        "email": "dontblameme@example.org" 
      },
      {
        "name": "Charlotte C.",
        "type": "author",
        "email": "iambecomingasketchcomedian@example.com" 
      }
    ]


Contributors
------------

A list of contact entries for other contributors not already listed as
current project points of contact. The subfields within the list elements
are the same as those for the main contact field.

Example::

    "contributors": [
        {"name": "John C."},
        {"name": "Erik I."},
        {"name": "Terry G."},
        {"name": "Mike P."},
        {"name": "Graeme C."},
        {"name": "Terry J."}
    ]

.. note::
    
   Similar to the long description, we may not want to encourage including
   the full contributor list in the main metadata, since it's rarely going to be
   of programmatic interest. A standard file name with a suitably defined
   format (such as ``AUTHORS`` with "name <email> (url)" entries) may be a
   better idea here as well.


Project URLs
------------

A mapping of arbitrary text labels to additional URLs relevant to the project.

While projects are free to choose their own labels and specific URLs,
it is RECOMMENDED that home page, source control, issue tracker and
documentation links be provided using the labels in the example below.

URL labels MUST be treated as case insensitive by automated tools, but they
are not required to be valid Python identifiers. Any legal JSON string is
permitted as a URL label.

Example::
    
    "project_urls": {
        "Documentation": "https://distlib.readthedocs.org"
        "Home": "https://bitbucket.org/pypa/distlib"
        "Source": "https://bitbucket.org/pypa/distlib/src"
        "Tracker": "https://bitbucket.org/pypa/distlib/issues"
    }


Dependency metadata
===================

Dependency metadata allows distributions to make use of functionality
provided by other distributions, without needing to bundle copies of those
distributions.

Dependency management is heavily dependent on the version identification
and specification scheme defined in PEP 440.

.. note::
    
    This substantially changes the old two-phase setup vs runtime dependency
    model in metadata 1.2 (which was in turn derived from the setuptools
    dependency parameters). The translation is that ``dev_requires`` and
    ``build_requires`` both map to ``Setup-Requires-Dist``
    in 1.2, while ``requires`` maps to ``Requires-Dist``. To go the other
    way, ``Setup-Requires-Dist`` maps to ``build_requires`` and
    ``Requires-Dist`` maps to ``requires``.
    


Dependency specifications
-------------------------

Individual dependencies are typically defined as strings containing a
distribution name (as found in the ``name`` field). The dependency name
may be followed by an extras specifier (enclosed in square
brackets) and by a version specification (within parentheses).

See `Extras (optional dependencies)`_ for details on extras and PEP 440
for details on version specifiers.

The distribution names should correspond to names as found on the `Python
Package Index`_; while these names are often the same as the module names
as accessed with ``import x``, this is not always the case (especially
for distributions that provide multiple top level modules or packages).

Example dependency specifications::

    "Flask"
    "Django"
    "Pyramid"
    "SciPy (0.12)"
    "ComfyChair[warmup]"
    "ComfyChair[warmup] (> 0.1)"

In some situations, there may be multiple ways to satisfy a dependency. In
those cases, the dependency specification may be given as a nested list
rather than as a single string. If at least one of the individual
dependencies is already available, then the entire dependency is
considered satisfied, otherwise the first entry will be added to the
dependency set.

Alternative dependency specification example::

   ["Pillow", "PIL"]
   ["mysql", "psycopg2 (>= 4)", "sqlite3"]

.. note::

  I'm far from convinced supporting alternative dependencies is worth the
  extra complexity. If others think it's worth the hassle, this is my
  preferred syntax for it (since it slots in nicely as either a normal or
  conditional dependency), but I'm quite prepared to drop the idea entirely.

  Neither of the given examples is particularly compelling, since Pillow/PIL
  style forks aren't common, and the database driver use case would arguably
  be better served by a "supported database driver" metadata extension.

  We're also getting better support for "virtual provides" in this version
  of the metadata standard, so this may end up being an installer and index
  server problem to better track and publish those.


Conditional dependencies
------------------------

While many dependencies will be needed to use a distribution at all, others
are needed only on particular platforms or only when particular optional
features of the distribution are needed. To enable this, dependency fields
are marked as either unconditional (indicated by ``requires`` in the field
name) or conditional (indicated by ``may_require``) in the field name.

Unconditional dependency fields are lists of dependency specifications, with
each entry indicated a required dependency.

Conditional dependencies are lists of mappings with the following fields:

* ``dependencies``: a list of relevant dependency specifications
* ``extra``: the name of the optional feature that needs these dependencies.
  See `Extras (optional dependencies)`_ for details.
* ``environment``: an environment marker defining the environment that
  needs these dependencies. See `Environment markers`_ for details.

The ``dependencies`` field is required, as is at least one of ``extra`` and
``environment``. All three fields may be supplied, indicating that the
dependency is needed only for a particular optional feature when in a
particular environment.

Note that the same extras and environment markers MAY appear in multiple
conditional dependencies. This may happen, for example, if an extra itself
only needs some of its dependencies in specific environments.

.. note::
    
   Technically, you could store the conditional and unconditional
   dependencies in a single list and switch based on the entry type
   (string or mapping), but the ``*requires`` vs ``*may-require`` two
   list design seems easier to understand and work with.


Mapping dependencies to development and distribution activities
---------------------------------------------------------------

The different categories of dependency are based on the various distribution
and development activities identified above, and govern which dependencies
should be installed for the specified activities:

* Deployment dependencies:
    
    * ``requires``
    * ``may_require`` (checks runtime extras and environment markers)
    * install the ``test`` extra to get the test dependencies

* Build dependencies:
    
    * ``build_requires``
    * ``build_may_require`` (checks build extras and environment markers)
    * request the ``docs`` extra to be able to build the documentation

* Development dependencies:
    
    * ``requires``
    * ``may_require`` (all runtime extras, checks environment markers)
    * ``build_requires``
    * ``build_may_require`` (all build extras, checks environment markers)
    * ``dev_requires``

Installation tools SHOULD allow users to request at least the following
operations for a named distribution:
    
* Install the distribution and any deployment dependencies.
* Install just the build dependencies without installing the distribution
* Install just the development dependencies without installing
  the distribution

The notation described in `Extras (optional dependencies)`_ SHOULD be used to
request additional optional dependencies when installing deployment
or build dependencies. Installing the development dependencies should always
install all optional dependencies, as well as any platform appropriate
conditional dependencies.

Installation tools SHOULD report an error if dependencies cannot be found,
MUST at least emit a warning, and MAY allow the user to force the
installation to proceed regardless.

.. note::
    
    As an example of mapping this to Linux distro packages, assume an
    example project with documentation but no optional features is split
    into 3 RPMs in a SPEC file: example, example-devel and example-docs
    
    The requires and applicable may-require dependencies would be mapped
    to the Requires dependencies for the "example" RPM (a mapping from
    environment markers to SPEC file conditions would also allow those to
    be handled correctly)
    
    The build-requires and build-may-require dependencies would be mapped
    to the BuildRequires dependencies for the "example" RPM *except* for
    the "[docs]" build dependencies (i.e. any entries in build-may-require
    where the feature subfield is set to "docs").
    
    The "[docs]" build dependencies would instead be mapped to the
    BuildRequires for the "example-docs" RPM
    
    All defined dependencies relevant to Linux would become Requires
    dependencies for the "example-devel" RPM.
    
    If a project defines optional features that need additional
    dependencies, those could be mapped to additional virtual RPMs with
    no BuildRequires but appropriate Requires entries.


Requires
--------

A list of other distributions needed when this distribution is deployed.

Example::

    "requires": ["SciPy", "PasteDeploy", "zope.interface (>3.5.0)"]


May require
-----------

A list of other distributions that may be needed when this distribution
is deployed, based on the features requested and the target deployment
environment.

Any extras referenced from this field MUST be named in the `Extras`_ field.
The one exception is ``test``, which is implicitly defined for all
distributions.

Example::

        "may_require": [
          {
            "dependencies": ["pywin32 (>1.0)"],
            "environment": "sys.platform == 'win32'"
          },
          {
            "dependencies": ["SoftCushions"],
            "extra": "warmup"
          },
          {
            "dependencies": ["unittest2"],
            "extra": "test"
          }
        ]

Extras
------

A list of optional runtime feature names that may be used in conditional
dependencies in ``"may_require"``. See `Extras (optional dependencies)`_
for details.

The runtime extra ``"test"`` is implicitly defined for all distributions
and MUST NOT be recorded explicitly in this field.

Example::
    
    "extras": ["warmup"]


Build requires
--------------

A list of other distributions needed when this distribution is being built
(creating a binary archive from a source archive).

Note that while these are build dependencies for the distribution being
built, the installation is a *deployment* scenario for the dependencies.

Example::

    "build_requires": ["setuptools (>= 0.7)"]


Build may require
-----------------

A list of other distributions that may be needed when this distribution
is built (creating a binary archive from a source archive), based on the
features requested and the build environment.

Note that while these are build dependencies for the distribution being
built, the installation is a *deployment* scenario for the dependencies.

Any extras referenced from this field MUST be named in the `Build extras`_
field. The one exception is ``docs``, which is implicitly defined for all
distributions.

Example::

        "build_may_require": [
          {
            "dependencies": ["pywin32 (>1.0)"],
            "environment": "sys.platform == 'win32'"
          },
          {
            "dependencies": ["cython"],
            "extra": "c-accelerators"
          },
          {
            "dependencies": ["sphinx (>= 1.0)"],
            "extra": "docs"
          }
        ]


Build extras
------------

A list of optional build feature names that may be used in conditional
dependencies in ``"build_may_require"``. See
`Extras (optional dependencies)`_ for details.

The build extra ``"docs"`` is implicitly defined for all distributions
and MUST NOT be recorded explicitly in this field.

Example::
    
    "build_extras": ["c-accelerators"]


Dev requires
------------

A list of any additional distributions needed during development of this
distribution that aren't already covered by the deployment and build
dependencies.

This is generally limited to the distributions specifically needed to
create a source archive.

Example::

    "dev_requires": ["hgtools"]

.. note::

   Only unconditional development dependencies are supported, as I am not
   aware of any use cases where generating a source archive is likely to
   require environment specific dependencies. Instead, those are more
   likely to be environment specific runtime dependencies of the tool
   that supports creation of the source archive.

   A separate implied ``"dev"`` build extra may be an adequate substitute
   for this field.


Provides
--------

A list of strings naming additional dependency requirements that are
satisfied by installing this distribution. These strings must be of the
form ``Name`` or ``Name (Version)``, as for the ``requires`` field.

While dependencies are usually resolved based on distribution names and
versions, a distribution may provide additional names explicitly in the
``provides`` field.

For example, this may be used to indicate that multiple projects have
been merged into and replaced by a single distribution or to indicate
that this project is a substitute for another.

For instance, distribute (a one time fork of setuptools) could include a
``"provides": ["setuptools"]`` entry to prevent the conflicting package from
being downloaded and installed when distribute is already
installed.

With distribute merged back into setuptools, the merged project is able to
include a ``"provides": ["distribute"]`` entry to satisfy any projects that
require the now obsolete distribution's name.

A distribution may also provide a "virtual" project name, which does
not correspond to any separately distributed project:  such a name
might be used to indicate an abstract capability which could be supplied
by one of multiple projects.  For example, multiple projects might supply
PostgreSQL bindings for use with SQL Alchemy: each project might declare
that it provides ``sqlalchemy-postgresql-bindings``, allowing other
projects to depend only on having at least one of them installed.

A version declaration may be supplied and must follow the rules described
in PEP 440. The distribution's version identifier will be implied
if none is specified.

Example::

    "provides": ["AnotherProject (3.4)", "virtual_package"]

.. note::
    
   Under the revised metadata design, conditional "provides" based on
   runtime features or the environment would go in a separate "may_provide"
   field. However, I'm not convinced there's a great use case for that,
   so I'm inclined to leave the addition of such a field to v2.1 of the
   metadata spec (at the earliest, and only if someone comes up with a
   compelling use case)


Obsoleted by
------------

A string that indicates that this project is no longer being developed.  The
named project provides a substitute or replacement.

A version declaration may be supplied and must follow the rules described
in `Version specifiers`_.

Possible uses for this field include handling project name changes and
project mergers.

Unlike ``provides``, there is no expectation that the replacement project
will be a "drop-in" replacement for the obsolete project - at the very
least, upgrading to the new distribution is likely to require changes
to import statements.

Examples::

    "name": "BadName",
    "obsoleted_by": "AcceptableName"

    "name": "SeparateProject",
    "obsoleted_by": "MergedProject (>=4.0.0)"


Supports Platforms
------------------

A list of strings specifying the platforms that the distribution
explicitly supports. A platform is considered supported if it
matches at least one of the environment markers given.

If this field is not given in the metadata, it is assumed that the
distribution supports any platform supported by Python.

Individual entries are environment markers, as described in
`Conditional metadata (environment markers)`_.

Installation tools SHOULD report an error if supported platforms are
specified by the distribution and the current platform fails to match
any of them, MUST at least emit a warning, and MAY allow the user to
force the installation to proceed regardless.

Examples::

   "supports_platforms": ["sys_platform == 'win32'"]
   "supports_platforms": ["sys_platform != 'win32'"]
   "supports_platforms": ["'linux' in sys_platform", "'bsd' in sys_platform"]


.. note:: 

   This field replaces the old Platform, Requires-Platform and
   Requires-Python fields and has been redesigned with environment
   marker based semantics that should make it possible to reliably flag,
   for example, Unix specific or Windows specific modules, as well
   as Python 2 only and Python 3 only modules.


Metabuild system
================

.. note::

   It's not yet clear how much of this section needs to be in metadata 2.0,
   and how much can and should be delayed to later versions. At the moment,
   this doc is about "Where do we want to get to?", before harsh reality
   sets in and we have to decide "OK, that's nice and all, but what do we do
   *first*?"

   preinstall/postuninstall seem to be the bare minimum, since we want
   something that will work for Twisted, and those two hooks can't be
   delayed until 2.1 (as 2.0 only tools wouldn't run them even for projects
   that really needed them)

The metabuild system defines several distinct operations as part of the
development and deployment lifecycle for a distribution:

* Generating the metadata file on a development system
* Generating a source archive on a development system
* Generating a binary archive on a build system
* Installing to a deployment system
* Uninstalling from a deployment system
* Running the distribution's test suite on a deployment system (hence the
  ``test`` runtime extra)

Note that building documentation that is not shipped as part of binary
archives is not considered part of the metabuild system, even though
the relevant dependencies may be declared as part of the distribution
metadata.

.. note::

   Previous paragraph assumes that building the docs is split out to a
   separate top level docs-build-requires/docs-build-may-require pair.

Each of these operations is declared as an "entry point", a reference
to a Python callable, with the module name separated from the reference
within the module by a colon (``:``).

Example entry point::

    "myproject.build:postinstall"

Build and installation tools MAY offer additional operations beyond the
core metabuild operations. These operations SHOULD be composed from the
defined metabuild operations where appropriate.

The metabuild hooks are gathered together into a single top level
``metabuild_hooks`` field. The individual hooks are:

* ``make_dist_info``: generate the source archive's dist_info directory
* ``make_sdist``: construct a source archive
* ``build_wheel``: construct a binary wheel archive from an sdist source
  archive
* ``postinstall``: run after the distribution has been installed to a
  target deployment system (or after it has been upgraded)
* ``preuninstall``: run before the distribution has been uninstalled from a
  deployment system (or before it is upgraded)
* ``check_install``: check that a distribution is correctly installed

The expected signatures of these hooks are as follows::

    def make_dist_info(source_dir, info_dir):
        """Generate the contents of dist_info for an sdist archive

        *source_dir* points to a source checkout or unpacked tarball
        *info_dir* is the destination where the sdist metadata files should
        be written

        Returns the distribution metadata as a dictionary.
        """

    def make_sdist(source_dir, contents_dir, info_dir):
        """Generate the contents of an sdist archive

        *source_dir* points to a source checkout or unpacked tarball
        *contents_dir* is the destination where the sdist contents should be
        written (note that archiving the contents is the responsibility of
        the metabuild tool rather than the hook function)
        *info_dir* is the destination where the sdist metadata files should
        be written

        Returns the distribution metadata as a dictionary.
        """

    def build_wheel(sdist_dir, contents_dir, info_dir, compatibility=None):
        """Generate the contents of a wheel archive

        *source_dir* points to an unpacked source archive
        *contents_dir* is the destination where the wheel contents should be
        written (note that archiving the contents is the responsibility of
        the metabuild tool rather than the hook function)
        *info_dir* is the destination where the wheel metadata files should
        be written
        *compatibility* is an optional PEP 425 compatibility tag indicating
        the desired target compatibility for the build. If the tag cannot
        be satisfied, the hook should throw ``ValueError``.

        Returns the actual compatibility tag for the build
        """

    def postinstall(current_meta, previous_meta=None):
        """Run following installation or upgrade of the distribution

        *current_meta* is the distribution metadata for the version now
        installed on the current system
        *previous_meta* is either missing or ``None`` (indicating a fresh
        install) or else the distribution metadata for the version that
        was previously installed (indicating an upgrade or downgrade).
        """

    def preuninstall(current_meta, next_meta=None):
        """Run prior to uninstallation or upgrade of the distribution

        *current_meta* is the distribution metadata for the version now
        installed on the current system
        *next_meta* is either missing or ``None`` (indicating complete
        uninstallation) or else the distribution metadata for the version
        that is about to be installed (indicating an upgrade or downgrade).
        """

    def test_install(current_meta):
        """Test whether or not the distribution is working correctly

        Note that this check should always be non-destructive as it may be
        invoked automatically by some tools.

        Requires that the distribution's test dependencies be installed.

        Returns ``True`` if the testing passes, ``False`` otherwise.
        """


Extras (optional dependencies)
==============================

.. note::

   As noted at the top of the current draft, there's an open question of
   how to deal with things like optional C accelerators. Perhaps kill the
   "build extras" idea and require that such components be split out to a
   separate distribution to be considered truly optional?

Extras are additional dependencies that enable optional features
of the distribution, generally corresponding to a ``try: import
optional_dependency ...`` block in the code.  To support the use of the
distribution with or without the optional dependencies they are listed
separately from the distribution's core dependencies and must be requested
explicitly, either in the dependency specifications of another distribution,
or else when issuing a command to an installation tool.

The names of extras MUST abide by the same restrictions as those for
distribution names.

Example of a distribution with optional dependencies::
    
    "name": "ComfyChair",
    "may_require": [
      {
        "dependencies": ["SoftCushions"],
        "extra": "warmup"
      },
      {
        "dependencies": ["unittest2"],
        "extra": "test"
      }
    ]
    "build_may_require": [
      {
        "dependencies": ["cython"],
        "extra": "c-accelerators"
      },
      {
        "dependencies": ["sphinx (>= 1.0)"],
        "extra": "docs"
      }
    ]

Other distributions require the additional dependencies by placing the
relevant extra names inside square brackets after the distribution name when
specifying the dependency. Multiple features can be requested by separating
them with a comma within the brackets, and all defined optional features may
be requested with the ``*`` wildcard character. Optional features may be
excluded by prefixing their name with a hyphen.

Command line based installation tools SHOULD support this same syntax to
allow optional features to be requested explicitly.

The full set of dependency requirements is then based on the top level
dependencies, along with those of any requested optional features.

Example::

    "requires": ["ComfyChair[warmup]"]
        -> requires ``ComfyChair`` and ``SoftCushions`` at run time

    "requires": ["ComfyChair[*,-test]"]
        -> requires ``ComfyChair`` and ``SoftCushions`` at run time, but
           will also pick up any new optional dependencies other than those
           needed solely to run the tests


Environment markers
===================

An **environment marker** describes a condition about the current execution
environment. They are used to indicate when certain dependencies are only
required in particular environments, and to indicate supported platforms
for distributions with additional constraints beyond the availability of a
Python runtime.

Here are some examples of such markers::

   "sys_platform == 'win32'"
   "platform_machine == 'i386'"
   "python_version == '2.4' or python_version == '2.5'"
   "'linux' in sys_platform"

And here's an example of some conditional metadata for a distribution that
requires PyWin32 both at runtime and buildtime when using Windows::
    
    "name": "ComfyChair",
    "may_require": [
      {
        "dependencies": ["pywin32 (>1.0)"],
        "environment": "sys.platform == 'win32'"
      }
    ]
    "build_may_require": [
      {
        "dependencies": ["pywin32 (>1.0)"],
        "environment": "sys.platform == 'win32'"
      }
    ]

The micro-language behind this is a simple subset of Python: it compares
only strings, with the ``==`` and ``in`` operators (and their opposites),
and with the ability to combine expressions. Parentheses are supported
for grouping.

.. note::
    
    Open question: should we add at least ".startswith" and ".endswith"
    support to this? ``"sys.platform.startswith('win')"`` is a somewhat more
    intuitive way to mark Windows specific dependencies, since
    ``"'win' in sys.platform"`` is incorrect thanks to ``cygwin`` and the 
    fact that 64-bit Windows still shows up as ``win32`` is more than a
    little strange.
    
    Open question: should PEP 440 style comparisons be made available for at
    least ``python_version`` and ``python_full_version``? The downside of
    doing so is that it would mean environment markers are no longer a
    Python subset.

The pseudo-grammar is ::

    MARKER: EXPR [(and|or) EXPR]*
    EXPR: ("(" MARKER ")") | (SUBEXPR [(in|==|!=|not in)SUBEXPR])

where ``SUBEXPR`` belongs to any of the following (the details after the
colon in each entry define the value represented by that subexpression):

* ``python_version``: ``'%s.%s' % (sys.version_info[0], sys.version_info[1])``
* ``python_full_version``: ``sys.version.split()[0]``
* ``os_name````: ``os.name``
* ``sys_platform````: ``sys.platform``
* ``platform_version``: ``platform.version()``
* ``platform_machine``: ``platform.machine()``
* ``platform_python_implementation``: ``platform.python_implementation()``
* ``'text'``: a free string, like ``'2.4'``, or ``'win32'``

Note that all subexpressions are restricted to strings or one of the
predefined variable names, meaning that it is not possible to use
other sequences like tuples or lists on the right side of the ``in`` and
``not in`` operators.

Unlike Python, chaining of comparison operations is NOT permitted in
environment markers.


Metadata Extensions
===================

Extensions
----------

Extensions to the metadata may be present in a mapping under the
'extensions' key.  The keys must meet the same restrictions as
distribution names, while the values may be any type natively supported
in JSON::

    "extensions" : { 
        "chili" : { "type" : "Poblano", "heat" : "Mild" },
        "languages" : [ "French", "Italian", "Hebrew" ]
    }

To avoid name conflicts, it is recommended that distribution names be used
to identify metadata extensions. This practice will also make it easier to
find authoritative documentation for metadata extensions.

Legacy metadata
===============

A temporary home for fields that are poorly defined, of dubious utility,
and may be dropped or replaced entirely, but aren't quite dead yet...


Requires-External (multiple use)
--------------------------------

Each entry contains a string describing some dependency in the
system that the distribution is to be used.  This field is intended to
serve as a hint to downstream project maintainers, and has no
semantics which are meaningful to the ``distutils`` distribution.

Notice that there is no particular rule on the strings to be used.

Examples::

    Requires-External: C
    Requires-External: libpng (>=1.5)
    
.. note::
    
   External dependencies are such a complex beast, I'm inclined to kill
   this field completely, and instead recommend that external dependencies
   (and ensuring their presence) be handled in the post-install hook. It's
   just too platform dependent for us to handle in a generic way.

   Particular projects and build systems may then define metadata extensions
   to transport their own flavour of external dependency definitions.


Updating the metadata specification
===================================

The metadata specification may be updated with clarifications without
requiring a new PEP or a change to the metadata version.

Adding new features (other than through the extension mechanism), or
changing the meaning of existing fields, requires a new metadata version
defined in a new PEP.


Summary of differences from \PEP 345
====================================

.. note::

   The summary of differences and the rational section will be updated
   once the new format stabilises further.


* Metadata-Version is now 2.0, with semantics specified for handling
  version changes

* Most fields are now optional

* Explicit permission for in-place clarifications without releasing a new
  version of the specification

* General reformatting of the PEP to make it easier to read

* Values are now expected to be UTF-8

* Changed the version scheme

  * added the new ``Private-Version`` field
  * changed the top level sort position of the ``.devN`` suffix
  * allowed single value version numbers
  * explicit exclusion of leading or trailing whitespace
  * explicit criterion for the exclusion of date based versions
  * incorporated the version scheme directly into the PEP

* Changed interpretation of version specifiers

  * implicitly exclude pre-releases unless explicitly requested
  * treat post releases the same way as unqualified releases

* Discuss ordering and dependencies across metadata versions

* Clarify use of parentheses for grouping in environment marker
  pseudo-grammar

* Support for packaging, build and installation dependencies

   * the new ``Setup-Requires-Dist`` field

* Optional feature mechanism

   * the new ``Provides-Extra`` field
   * ``extra`` expression defined for environment markers
   * optional feature support in ``Requires-Dist``

* Metadata extension mechanism

   * the new ``Extension`` field and extension specific fields

* Updated obsolescence mechanism

   * the new ``Obsoleted-By`` field
   * the ``Obsoletes-Dist`` field has been removed

* Simpler description format

   * the ``Description`` field is now deprecated
   * A payload (containing the description) may appear after the headers.

* Other changed fields:

  - ``Requires-Python`` (explicitly flagged as multiple use)
  - ``Project-URL`` (commas permitted in labels)

* Clarified fields:

  - ``Provides-Dist``
  - ``Keywords``

The rationale for major changes is given in the following sections.


Metadata-Version semantics
--------------------------

The semantics of major and minor version increments are now specified,
and follow the same model as the format version semantics specified for
the wheel format in PEP 427: minor version increments must behave
reasonably when processed by a tool that only understand earlier metadata
versions with the same major version, while major version increments
may include changes that are not compatible with existing tools.

The major version number of the specification has been incremented
accordingly, as interpreting PEP 426 metadata in accordance with earlier
metadata specifications is unlikely to give the expected behaviour.

Whenever the major version number of the specification is incremented, it
is expected that deployment will take some time, as either metadata
consuming tools must be updated before other tools can safely start
producing the new format, or else the sdist and wheel formats, along with
the installation database definition, will need to be updated to support
provision of multiple versions of the metadata in parallel.

Existing tools won't abide by this guideline until they're updated to
support the new metadata standard, so the new semantics will first take
effect for a hypothetical 2.x -> 3.0 transition. For the 1.x -> 2.0
transition, it is recommended that tools continue to produce the
existing supplementary files (such as ``entry_points.txt``) in addition
to any equivalents specified using the new features of the standard
metadata format (including the formal extension mechanism).


Standard encoding and other format clarifications
-------------------------------------------------

Several aspects of the file format, including the expected file encoding,
were underspecified in previous versions of the metadata standard. To
make it easier to develop interoperable tools, these details are now
explicitly specified.


Changing the version scheme
---------------------------

The new ``Private-Version`` field is intended to make it clearer that the
constraints on public version identifiers are there primarily to aid in
the creation of reliable automated dependency analysis tools. Projects
are free to use whatever versioning scheme they like internally, so long
as they are able to translate it to something the dependency analysis tools
will understand.

The key change in the version scheme in this PEP relative to that in
PEP 386 is to sort top level developmental releases like ``X.Y.devN`` ahead
of alpha releases like ``X.Ya1``. This is a far more logical sort order, as
projects already using both development releases and alphas/betas/release
candidates do not want their developmental releases sorted in
between their release candidates and their full releases. There is no
rationale for using ``dev`` releases in that position rather than
merely creating additional release candidates.

The updated sort order also means the sorting of ``dev`` versions is now
consistent between the metadata standard and the pre-existing behaviour
of ``pkg_resources`` (and hence the behaviour of current installation
tools).

Making this change should make it easier for affected existing projects to
migrate to the latest version of the metadata standard.

Another change to the version scheme is to allow single number
versions, similar to those used by non-Python projects like Mozilla
Firefox, Google Chrome and the Fedora Linux distribution. This is actually
expected to be more useful for version specifiers (allowing things like
the simple ``Requires-Python: 3`` rather than the more convoluted
``Requires-Python: >= 3.0, < 4``), but it is easier to allow it for both
version specifiers and release numbers, rather than splitting the
two definitions.

The exclusion of leading and trailing whitespace was made explicit after
a couple of projects with version identifiers differing only in a
trailing ``\n`` character were found on PyPI.

The exclusion of major release numbers that looks like dates was implied
by the overall text of PEP 386, but not clear in the definition of the
version scheme. This exclusion has been made clear in the definition of
the release component.

Finally, as the version scheme in use is dependent on the metadata
version, it was deemed simpler to merge the scheme definition directly into
this PEP rather than continuing to maintain it as a separate PEP.

`Appendix B` shows detailed results of an analysis of PyPI distribution
version information, as collected on 19th February, 2013. This analysis
compares the behaviour of the explicitly ordered version schemes defined in
this PEP and PEP 386 with the de facto standard defined by the behaviour
of setuptools. These metrics are useful, as the intent of both PEPs is to
follow existing setuptools behaviour as closely as is feasible, while
still throwing exceptions for unorderable versions (rather than trying
to guess an appropriate order as setuptools does).

Overall, the percentage of compatible distributions improves from 97.7%
with PEP 386 to 98.7% with this PEP. While the number of projects affected
in practice was small, some of the affected projects are in widespread use
(such as Pinax and selenium). The surprising ordering discrepancy also
concerned developers and acted as an unnecessary barrier to adoption of
the new metadata standard.

The data also shows that the pre-release sorting discrepancies are seen
only when analysing *all* versions from PyPI, rather than when analysing
public versions. This is largely due to the fact that PyPI normally reports
only the most recent version for each project (unless maintainers
explicitly configure their project to display additional versions). However,
installers that need to satisfy detailed version constraints often need
to look at all available versions, as they may need to retrieve an older
release.

Even this PEP doesn't completely eliminate the sorting differences relative
to setuptools:

* Sorts differently (after translations): 38 / 28194 (0.13 %)
* Sorts differently (no translations): 2 / 28194 (0.01 %)

The two remaining sort order discrepancies picked up by the analysis are due
to a pair of projects which have PyPI releases ending with a carriage
return, alongside releases with the same version number, only *without* the
trailing carriage return.

The sorting discrepancies after translation relate mainly to differences
in the handling of pre-releases where the standard mechanism is considered
to be an improvement. For example, the existing pkg_resources scheme will
sort "1.1beta1" *after* "1.1b2", whereas the suggested standard translation
for "1.1beta1" is "1.1b1", which sorts *before* "1.1b2". Similarly, the
pkg_resources scheme will sort "-dev-N" pre-releases differently from
"devN" pre-releases when they occur within the same release, while the
standard scheme will normalize both representations to ".devN" and sort
them by the numeric component.


A more opinionated description of the versioning scheme
-------------------------------------------------------

As in PEP 386, the primary focus is on codifying existing practices to make
them more amenable to automation, rather than demanding that existing
projects make non-trivial changes to their workflow. However, the
standard scheme allows significantly more flexibility than is needed
for the vast majority of simple Python packages (which often don't even
need maintenance releases - many users are happy with needing to upgrade to a
new feature release to get bug fixes).

For the benefit of novice developers, and for experienced developers
wishing to better understand the various use cases, the specification
now goes into much greater detail on the components of the defined
version scheme, including examples of how each component may be used
in practice.

The PEP also explicitly guides developers in the direction of
semantic versioning (without requiring it), and discourages the use of
several aspects of the full versioning scheme that have largely been
included in order to cover esoteric corner cases in the practices of
existing projects and in repackaging software for Linux distributions.


Changing the interpretation of version specifiers
-------------------------------------------------

The previous interpretation of version specifiers made it very easy to
accidentally download a pre-release version of a dependency. This in
turn made it difficult for developers to publish pre-release versions
of software to the Python Package Index, as even marking the package as
hidden wasn't enough to keep automated tools from downloading it, and also
made it harder for users to obtain the test release manually through the
main PyPI web interface.

The previous interpretation also excluded post-releases from some version
specifiers for no adequately justified reason.

The updated interpretation is intended to make it difficult to accidentally
accept a pre-release version as satisfying a dependency, while allowing
pre-release versions to be explicitly requested when needed.

The "some forward compatibility assumed" default version constraint is
taken directly from the Ruby community's "pessimistic version constraint"
operator [4]_ to allow projects to take a cautious approach to forward
compatibility promises, while still easily setting a minimum required
version for their dependencies. It is made the default behaviour rather
than needing a separate operator in order to explicitly discourage
overspecification of dependencies by library developers. The explicit
comparison operators remain available to cope with dependencies with
unreliable or non-existent backwards compatibility policies.


Packaging, build and installation dependencies
----------------------------------------------

The new ``Setup-Requires-Dist`` field allows a distribution to indicate when
a dependency is needed to package, build or install the distribution, rather
than being needed to run the software after installation.

This should allow distribution tools to effectively support a wider range of
distribution requirements.


Support for optional features of distributions
----------------------------------------------

The new ``Provides-Extra`` field allows distributions to declare optional
features, and to use environment markers to reduce their dependencies
when those features are not requested. Environment markers may also be
used to require a later version of Python when particular features are
requested.

The ``Requires-Dist`` and ``Setup-Requires-Dist`` fields then allow
distributions to require optional features of other distributions.

The ``test`` and ``doc`` features are implicitly defined for all
distributions, as one key motivation for this feature is to encourage
distributions to explicitly declare the dependencies needed to run
their automatic tests, or build their documentation, without demanding those
dependencies be present in order to merely install or use the software.


Support for metadata extensions
-------------------------------

The new ``Extension`` field effectively allows sections of the metadata
namespace to be delegated to other distributions, while preserving a
standard overal format metadata format for easy of processing by
distribution tools that do not support a particular extension.

It also works well in combination with the new ``Setup-Requires-Dist`` field
to allow a distribution to depend on tools which *do* know how to handle
the chosen extension, and the new optional features mechanism, allowing
support for particular extensions to be provided as optional features.


Updated obsolescence mechanism
------------------------------

The marker to indicate when a project is obsolete and should be replaced
has been moved to the obsolete project (the new ``Obsoleted-By`` field),
replacing the previous marker on the replacement project (the removed
``Obsoletes-Dist`` field).

This should allow distribution tools to more easily warn users of
obsolete projects and their suggested replacements.

The ``Obsoletes-Dist`` header is removed rather than deprecated as it
is not widely supported, and so removing it does not present any significant
barrier to tools and projects adopting the new metadata format.


Simpler description format
--------------------------

Distribution descriptions are often quite long, sometimes including a
short guide to using the module. Moving them into the file payload allows
them to be formatted neatly as reStructuredText without needing to
carefully avoid the introduction of a blank line that would terminate
the header section.

The ``Description`` header is deprecated rather than removed to support
easier conversion of existing tools and projects to the new metadata
format.


References
==========

This document specifies version 2.0 of the metadata format.
Version 1.0 is specified in PEP 241.
Version 1.1 is specified in PEP 314.
Version 1.2 is specified in PEP 345.

The initial attempt at a standardised version scheme, along with the
justifications for needing such a standard can be found in PEP 386.

.. [1] reStructuredText markup:
   http://docutils.sourceforge.net/

.. _`Python Package Index`: http://pypi.python.org/pypi/

.. [2] PEP 301:
   http://www.python.org/dev/peps/pep-0301/

.. [3] Version compatibility analysis script:
   http://hg.python.org/peps/file/default/pep-0426/pepsort.py

.. [4] Pessimistic version constraint
   http://docs.rubygems.org/read/chapter/16

Appendix A
==========

The script used for this analysis is available at [3]_.

Parsing and generating the Metadata 2.0 serialization format using
Python 3.3::

    # Metadata 2.0 demo
    from email.generator import Generator
    from email import header
    from email.parser import Parser
    from email.policy import Compat32
    from email.utils import _has_surrogates

    class MetadataPolicy(Compat32):
        max_line_length = 0
        continuation_whitespace = '\t'

        def _sanitize_header(self, name, value):
            if not isinstance(value, str):
                return value
            if _has_surrogates(value):
                raise NotImplementedError()
            else:
                return value

        def _fold(self, name, value, sanitize):
            body = ((self.linesep+self.continuation_whitespace)
                    .join(value.splitlines()))
            return ''.join((name, ': ', body, self.linesep))

    if __name__ == "__main__":
        import sys
        import textwrap

        pkg_info = """\
    Metadata-Version: 2.0
    Name: package
    Version: 0.1.0
    Summary: A package.
    Description: Description
        ===========

        A description of the package.

    """

        m = Parser(policy=MetadataPolicy()).parsestr(pkg_info)

        m['License'] = 'GPL'
        description = m['Description']
        description_lines = description.splitlines()
        m.set_payload(description_lines[0]
                + '\n'
                + textwrap.dedent('\n'.join(description_lines[1:]))
                + '\n')
        del m['Description']

        # Correct if sys.stdout.encoding == 'UTF-8':
        Generator(sys.stdout, maxheaderlen=0).flatten(m)

Appendix B
==========

Metadata v2.0 guidelines versus setuptools::

    $ ./pepsort.py
    Comparing PEP 426 version sort to setuptools.

    Analysing release versions
      Compatible: 24477 / 28194 (86.82 %)
      Compatible with translation: 247 / 28194 (0.88 %)
      Compatible with filtering: 84 / 28194 (0.30 %)
      No compatible versions: 420 / 28194 (1.49 %)
      Sorts differently (after translations): 0 / 28194 (0.00 %)
      Sorts differently (no translations): 0 / 28194 (0.00 %)
      No applicable versions: 2966 / 28194 (10.52 %)

    Analysing public versions
      Compatible: 25600 / 28194 (90.80 %)
      Compatible with translation: 1505 / 28194 (5.34 %)
      Compatible with filtering: 13 / 28194 (0.05 %)
      No compatible versions: 420 / 28194 (1.49 %)
      Sorts differently (after translations): 0 / 28194 (0.00 %)
      Sorts differently (no translations): 0 / 28194 (0.00 %)
      No applicable versions: 656 / 28194 (2.33 %)

    Analysing all versions
      Compatible: 24239 / 28194 (85.97 %)
      Compatible with translation: 2833 / 28194 (10.05 %)
      Compatible with filtering: 513 / 28194 (1.82 %)
      No compatible versions: 320 / 28194 (1.13 %)
      Sorts differently (after translations): 38 / 28194 (0.13 %)
      Sorts differently (no translations): 2 / 28194 (0.01 %)
      No applicable versions: 249 / 28194 (0.88 %)

Metadata v1.2 guidelines versus setuptools::

    $ ./pepsort.py 386
    Comparing PEP 386 version sort to setuptools.

    Analysing release versions
      Compatible: 24244 / 28194 (85.99 %)
      Compatible with translation: 247 / 28194 (0.88 %)
      Compatible with filtering: 84 / 28194 (0.30 %)
      No compatible versions: 648 / 28194 (2.30 %)
      Sorts differently (after translations): 0 / 28194 (0.00 %)
      Sorts differently (no translations): 0 / 28194 (0.00 %)
      No applicable versions: 2971 / 28194 (10.54 %)

    Analysing public versions
      Compatible: 25371 / 28194 (89.99 %)
      Compatible with translation: 1507 / 28194 (5.35 %)
      Compatible with filtering: 12 / 28194 (0.04 %)
      No compatible versions: 648 / 28194 (2.30 %)
      Sorts differently (after translations): 0 / 28194 (0.00 %)
      Sorts differently (no translations): 0 / 28194 (0.00 %)
      No applicable versions: 656 / 28194 (2.33 %)

    Analysing all versions
      Compatible: 23969 / 28194 (85.01 %)
      Compatible with translation: 2789 / 28194 (9.89 %)
      Compatible with filtering: 530 / 28194 (1.88 %)
      No compatible versions: 547 / 28194 (1.94 %)
      Sorts differently (after translations): 96 / 28194 (0.34 %)
      Sorts differently (no translations): 14 / 28194 (0.05 %)
      No applicable versions: 249 / 28194 (0.88 %)


Copyright
=========

This document has been placed in the public domain.


..
   Local Variables:
   mode: indented-text
   indent-tabs-mode: nil
   sentence-end-double-space: t
   fill-column: 70
   End:
